# AgentSeed: Generating Autonomous Agents with Prompy as Intent Interface

**White Paper v1.0.0**
**Author:** Rogério Figurelli
**Date:** May 8, 2025

---

## Executive Summary

AgentSeed introduces a minimalist yet powerful archetype for generating autonomous agents using `.prompy` files as declarative intent interfaces. The core concept is that any agent can be "seeded" from a short, structured description, interpreted by large language models (LLMs) to yield complete, self-documenting, executable Python scripts. This drastically lowers the barrier to custom automation and represents a significant step forward in natural-language-based programming of intelligent agents.

The key innovation lies in treating `.prompy` files as **intent interfaces**. These files act as "seeds" that grow into fully functional agents. Each seed encapsulates a compact, unambiguous specification of behavior, enabling not just rapid prototyping but also reproducibility, version control, and human readability. Optional fields such as `model`, `inputs`, `author`, and `schedule` allow for richer automation scenarios without sacrificing simplicity.

Unlike prompt-based systems that require manual trial-and-error, or DSLs that introduce steep learning curves, AgentSeed delivers reliable code by standardizing how LLMs interpret user intent. This unlocks agent generation for a broader audience — including non-programmers, educators, researchers, and business users — and ensures that outputs are not merely fragments or suggestions, but full, operational agents aligned with cognitive or functional models (e.g., Perception–Decision–Action).

The architecture of AgentSeed is modular and extensible, comprising layers for input parsing, reasoning, code generation, and integration with real-world interfaces like schedulers or dashboards. Whether monitoring product prices, scraping thematic content, or executing recurring tasks, AgentSeed enables a new paradigm: **software generated by specifying purpose, not implementation**.

By combining the expressiveness of natural language with the precision of structured prompts, AgentSeed positions itself as a candidate standard for next-generation agent development — grounded in clarity, built for autonomy, and optimized for human-computer collaboration.

---

## 1  Introduction

In recent years, the emergence of large language models (LLMs) has radically transformed how humans interact with software. Tasks that once required deep programming expertise can now be expressed in natural language, allowing users to automate workflows, analyze data, or even generate applications through textual prompts. However, while this shift has lowered technical barriers, it has also introduced new challenges: prompt-based interactions are often fragile, inconsistent, difficult to reproduce, and not easily transferable or scalable.

**AgentSeed** addresses this problem by proposing a structured, declarative layer between human intent and LLM-generated code: the `.prompy` specification. Built on top of the Prompy language, AgentSeed treats each `.prompy` file as a high-level *intent interface* — a compact, human-readable artifact that precisely defines the goal of an autonomous software agent.

Rather than forcing users to navigate prompt engineering or domain-specific languages (DSLs), AgentSeed allows them to seed an agent with just a few lines:

```prompy
agent: File Watcher
task: Monitor a directory and notify if any file changes
```

From this minimal specification, AgentSeed generates:

* A natural-language prompt optimized for LLM consumption
* A fully structured Python script, ready to execute
* Inline documentation, metadata, and secure handling of inputs

This design enables users — whether technical or non-technical — to generate robust and reproducible automations with minimal overhead. The `.prompy` format is intentionally minimalist yet extensible, allowing additional fields such as `model`, `inputs`, `author`, or `output` to shape the behavior and deployment logic of the generated agent.

What sets AgentSeed apart is its alignment with **cognitive modeling paradigms**, such as the **Perception–Decision–Action (MCP)** loop, allowing agents to be structured with interpretable logic flows. This opens the door to more transparent, explainable, and reusable agent designs — not as monolithic black boxes, but as understandable, maintainable software units.

Ultimately, AgentSeed reframes the development of autonomous agents around a simple premise: *intent should be enough*. By unifying structured intent with deterministic prompt generation and complete code output, AgentSeed paves the way for a new generation of natural-language-driven agent ecosystems — lightweight to define, powerful in execution, and scalable by design.

---

## 2  Problem Statement

Building autonomous agents today faces major obstacles:

* Difficulty translating human intent into effective prompts.
* High dependence on technical skills or boilerplate tools.
* Lack of versioning and reusability in LLM-based workflows.
* Inconsistent or partial code generation from prompts.

---

## 3  Proposed Solutions

AgentSeed addresses these challenges by providing:

* A standardized `.prompy` format that expresses intent in a minimal, declarative way.
* A reasoning pipeline that transforms specifications into structured, repeatable prompts.
* A code generation engine producing complete, runnable `.py` files aligned with agent patterns.
* A flexible model that supports inputs, credentials, schedules, and metadata.

---

## 4  Core Principles

* **Declarative Minimalism**: An agent can be described in as little as two lines (`agent`, `task`).
* **Deterministic Prompting**: Prompts are generated from fields in a consistent, predictable way.
* **Cognitive Modeling**: Supports patterns like Perception–Decision–Action (MCP).
* **Complete Output**: Generates fully functional Python scripts, not fragments.
* **Organic Extensibility**: Easily grows with optional metadata like `inputs`, `model`, `author`.

---

## 5  Agent Lifecycle and Evolvability

A crucial aspect of AgentSeed is its support for lifecycle evolution. Agents generated via `.prompy` files are not static scripts; they are first-class intent representations. This means agents can evolve through small, version-controlled updates to their original seed specs.

Key stages of the AgentSeed lifecycle include:

* **Seeding**: Creating the initial `.prompy` spec to describe the agent's core behavior.
* **Germination**: Generating the first full Python implementation using a standard prompt engine.
* **Refinement**: Modifying the `.prompy` file to adjust behavior, add inputs, or change scheduling.
* **Branching**: Creating variant agents (e.g., for testing, staging, production) from the same seed.
* **Feedback Integration**: Incorporating logs or user feedback back into the `.prompy` spec (future feature).

This lifecycle model makes AgentSeed a foundation for continuous agent development (CAD), where the emphasis is on evolving declarative specs instead of rewriting codebases. Over time, this encourages reuse, collaboration, and even agent marketplaces where seeds, not scripts, are shared.

---

## 6  Architecture Overview

```
AgentSeed Architecture

1. Inputs
   └── .prompy files (declarative task specs)

2. Input Layer
   └── Lightweight parser for extracting agent, task, inputs, and metadata

3. Reasoning Layer
   ├── Prompt generation engine
   ├── Task template matcher (e.g., MCP model)
   └── LLM interface (e.g., OpenAI API)

4. Output Layer
   ├── Generated Python script with logic + inline documentation
   └── Metadata header (author, date, model)

5. Application Interfaces
   ├── CLI (`prompy run agent.prompy`)
   ├── Web UI for rapid prototyping
   └── Scheduler integration (e.g., cron, Airflow)
```

---

## 7  State of the Art Use Cases

* **Price Monitoring Agent**: Tracks prices on websites and sends alerts via email.
* **Thematic News Scraper**: Extracts topic-specific headlines and stores them in CSV.
* **File Change Notifier**: Watches files and sends alerts when changes occur.
* **Data Cleaning Assistant**: Automates tasks like outlier removal and null imputation.

---

## 8  Speculative or Future Use Cases

* Agents with feedback loops for real-time regeneration (RLHF-style learning).
* Auto-generation of microservices from `.prompy` specs.
* Educational tools where students describe tasks and receive code walkthroughs.
* Agent ecosystems built from shareable `.prompy` files for collaboration.

---

## 9  Example: Daily Weather Alert Agent

### .prompy Input (AgentSeed Specification)

```prompy
agent: Daily Weather Alert
task: Fetch weather forecast for a city and send it via email each morning
model: MCP
inputs:
  author: Rogério Figurelli
  city: São Paulo
  email:
    sender: weatherbot@yourdomain.com
    receiver: user@client.com
    smtp_server: smtp.yourdomain.com
    smtp_port: 587
    username: weatherbot@yourdomain.com
    password: your_password
  weather_api:
    key: your_openweathermap_api_key
    endpoint: http://api.openweathermap.org/data/2.5/weather
schedule: 08:00 daily
```

### Generated Prompt (Natural Language Instruction)

```
Create a Python script named "Daily Weather Alert" based on the MCP model (Perception–Decision–Action).
The agent should fetch the weather forecast for the city of São Paulo using the OpenWeatherMap API.
After retrieving the forecast, it should send an email with the main weather information.
Use requests for API calls and smtplib for email.
Weather and email configurations should be read from a JSON config file.
Include a docstring with the author's name and current date.
```

### Generated Python Script

```python
"""
Daily Weather Alert Agent - MCP Model

This autonomous agent follows the Perception–Decision–Action architecture:
1. PERCEPTION: Fetches current weather data for a target city.
2. DECISION: Parses and formats the forecast data for reporting.
3. ACTION: Sends an email with the forecast to the configured recipient.

Author: Rogério Figurelli
Date: May 8, 2025
"""

import requests
import smtplib
import json
from email.message import EmailMessage

with open('config.json', 'r') as config_file:
    config = json.load(config_file)

CITY = config.get("city", "São Paulo")
API_KEY = config["weather_api"]["key"]
API_ENDPOINT = config["weather_api"]["endpoint"]
EMAIL_CONFIG = config["email"]

def fetch_weather(city):
    url = f"{API_ENDPOINT}?q={city}&appid={API_KEY}&units=metric&lang=en"
    response = requests.get(url)
    data = response.json()
    if response.status_code == 200:
        weather = data["weather"][0]["description"]
        temp = data["main"]["temp"]
        return f"The current weather in {city} is {weather} with {temp}°C."
    else:
        return f"Failed to fetch weather for {city}. Response: {data.get('message', 'Unknown error')}"

def send_email(content):
    msg = EmailMessage()
    msg["Subject"] = f"Today's Weather Forecast for {CITY}"
    msg["From"] = EMAIL_CONFIG["sender"]
    msg["To"] = EMAIL_CONFIG["receiver"]
    msg.set_content(content)

    with smtplib.SMTP(EMAIL_CONFIG["smtp_server"], EMAIL_CONFIG["smtp_port"]) as server:
        server.starttls()
        server.login(EMAIL_CONFIG["username"], EMAIL_CONFIG["password"])
        server.send_message(msg)

def weather_agent():
    forecast = fetch_weather(CITY)
    print("Forecast:", forecast)
    send_email(forecast)

if __name__ == "__main__":
    weather_agent()
```

---

## 10  References

1. Figurelli, R. (2025). *Prompy: Compact Prompting for Full Python Pipelines*.
2. OpenAI. (2023). *GPT-4 Technical Report*.
3. Nilsson, N. J. (1998). *Artificial Intelligence: A New Synthesis*. Morgan Kaufmann.

---

## 11  License

Creative Commons Attribution 4.0 International (CC BY 4.0)
© 2025 Rogério Figurelli. This is a conceptual framework provided “as is” without warranty.

---
